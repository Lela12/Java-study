# 연산자
## 연산자와 연산식
+ 연산자란?
  + 프로그램에서 데이터를 처리하여 결과를 산출하는 것
  + 연산자 : 연산에서 사용되는 표시나 기호
  + 피연산자 : 연산되는 데이터
  + 연산식 : 연산자오 피연산자를 이용하여 연산의 과정을 기술한 것

  ``` 
  x + y
  x - y
  x * y + z
  x == y
  // 위 연산식에서 +, -, * ==는 연산자이고 x, y, z는 피연산자
  ```
  
  |연산자 종류|연산자|피연산자 수|산출값|기능 설명|
  |---------|--------|--------|--------|--------|
  |산술|+, -, *, /, %|이항|숫자|사칙연산 및 나머지 계산|
  |부호|+, -|단항|숫자|음수와 양수의 부호|
  |문자열|+|이항|문자열|두 문자열을 연결|
  |대입|=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=|이항|다양|우변의 값을 좌변의 변수에 대입|
  |증감|++, --|단항|숫자|1만큼 증가/감소|
  |비교|==, !=, >, <, >=, <=, instanceof|이항|boolean|값의 비교|
  |논리|!, &, \|, &&, \|\| |단항, 이항|boolean|논리적 NOT, AND, OR 연산|
  |조건|(조건식)?A:B|삼항|다양|조건식에 따라 A 또는 B 중 하나를 선택|
  |비트|~, &, \|, ^|단항, 이항|숫자, boolean|비트 NOT, AND, OR, XOR 연산|
  |쉬프트|>>, <<, >>>|이항|숫자|비트를 좌측/우측으로 밀어서 이동|
  
  ``` 
  필요한 피연산자의 수에 따 단항, 이항, 삼항 연산자로 구분
  단항 연산자 : ++x;
  이항 연산자 : x + y;
  삼항 연산자 : (sum>90) ? "A" : "B";
  ```
  
  + 연산식은 반드시 하나의 값을 산출, 연산자 수가 아무리 많아도 두 개 이상의 값을 산출하는 연산식은 없음
  + 보통 연산식의 값은 아래와 같이 변수에 저장

  ``` 
  int result = x + y;
  ```
  
  + 연산식은 아래와 같ㅇ 다른 연산식으 피연산 위치에도 올 수 있음

  ``` 
  boolean result = (x+y) < 5;
  // x와 y 변수의 값을 더한 값이 5볻 작은지 확인 후 결과값 true 또는 false를 result에 저장
  ```
  
  
## 연산의 방향과 우선순위
  |연산자|연산 방향|
  |---------|--------|
  |증감(++, --), 부호(+, -), 비트(~), 논리(!)|<--|
  |산술(*, /, %)|-->|
  |산술(+, -)|-->|
  |쉬프트(<<, >>, >>>)|-->|
  |비교(<, >, <=, >=, instanceof)|-->|
  |비교(==, !=)|-->|
  |논리(&)|-->|
  |논리(^)|-->|
  |논리(\|)|-->|
  |논리(&&)|-->|
  |논리(\|\|)|-->|
  |조건(?:)|-->|
  |대입(=, +=, -=, *=, /=, %=, ^=, |=, <<=, >>=, >>>=)|<--|
  + 위에서 아래로 내려올수록 우선순위가 낮아짐
  
  ``` 
  1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.
  2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다.
  3. 단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다. (-->)
  4. 복잡한 연산식에서 괄호()를 사용하여 우선순위를 정해준다.
  ```

## 단항 연산자
### 부호 연산자 (+, -)
  + 양수 및 음수를 표시하는 +, -
  + boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용
  |연산식|설명|
  |-----|-----|
  |+|피연산자의 부호 유지|
  |-|피연산자의 부호 변경|
  ``` 
  int x = -100;
  int result1 = +x; // -100
  int result2 = -x; // 100
  ```
  + 부호 연산자의 산출 타입은 int 타입이라 short 타입 값을 부호 연산하면 int 타입 값으로 변경됨
  ``` 
  short s = 100;
  short result3 = -s; //컴파일 에러
  int result4 = -s;   //
  ```
  
### 증감 연산자 (++, --)
  + 변수의 값을 1 증가(++) 혹은 1 감소(--)
  + boolean 타입을 제외한 모든 기본 타입에 사용
  |연산식|설명|
  |-----|-----|
  |++x|다른 연산을 수행하기 전에 x 값을 1 증가|
  |--x|다른 연산을 수행하기 전에 x 값을 1 감소|
  |x++|다른 연산을 수행한 후에 x 값을 1 증가|
  |x--|다른 연산을 수행한 후에 x 값을 1 감소|
    + ++i, i++ 모두 i = i + 1;로 동일
    + --i, i-- 모두 i = i - 1;로 동일
      + 컴파일 시 ++i랑 i = i + 1은 동일한 바이트 코드가 생성되기 때문에 연산속도는 똑같음
  ``` 
  int x = 1;
  int y = 1;
  int result1 = ++x + 10; //12
  int result1 = y++ + 10; //11
  ```
  
### 논리 부정 연산자 (!)
  + true를 false로 false는 true로 변경하기 때문에 boolean 타입에만 사용

### 비트 반전 연산자 (~)
  + 정수타입(byte, short, int, long)에 사용
  + 피연산자를 2진수로 표현했을 때 비트값인 0을 1으로 1은 0으로 반전 
    + 정수값을 총 32비트의 이진 문자열로 리턴하는 Integer.toBinaryString() 메소드를 사용
  + 부호 비트인 최상위 비트를 포함해 모든 비트가 반전되어 부호가 반대인 새로운 값이 산출
  + 산출 타입은 int 타입
  ``` 
  byte v = 10;
  byte v1 = ~v; //컴파일 에러
  int v1 = ~v;
  ```
  
## 이항 연산자
  + 피연산작 2개인 연산자
  + 산술, 문자열 연결, 대입, 비교, 논리, 비트 논리, 비트 이동 연산자

### 산술 연산자 (+, -, *, /, %)
  + boolean 타입을 제외한 모든 기본 타입에 사용
  ``` 
  a + b : 덧셈 연산
  a - b : 뺄셈 연산
  a * b : 곱셈 연산
  a / b : 좌측 피연산자를 우측 피연산자로 나눗셈 연산
  a % b : 좌측 피연산자를 우측 피연산자로 나눈 나머지를 구하는 연산
  ```
  + 피연산자들이 모두 정수 타입이고 int 타입보다 작은 경우 모두 int 타입으로 변환
  + 피연산자들의 타입이 동일하지 않은 경우 큰 타입의 피연산자 타입으로 피연산자들의 타입을 일치시킨 후 연산
  + 피연산자 중 하나랃 실수 타입이며 실수 타입으로 산출
    + 예1) byte + int -> int + int = int
    + 예2) int + long -> long + long = long 
    + 예3) int + double -> double + double = double
  + char 
