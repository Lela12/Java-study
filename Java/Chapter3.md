# 연산자
## 연산자와 연산식
+ 연산자란?
  + 프로그램에서 데이터를 처리하여 결과를 산출하는 것
  + 연산자 : 연산에서 사용되는 표시나 기호
  + 피연산자 : 연산되는 데이터
  + 연산식 : 연산자오 피연산자를 이용하여 연산의 과정을 기술한 것

  ``` 
  x + y
  x - y
  x * y + z
  x == y
  // 위 연산식에서 +, -, * ==는 연산자이고 x, y, z는 피연산자
  ```
  
  |연산자 종류|연산자|피연산자 수|산출값|기능 설명|
  |---------|--------|--------|--------|--------|
  |산술|+, -, *, /, %|이항|숫자|사칙연산 및 나머지 계산|
  |부호|+, -|단항|숫자|음수와 양수의 부호|
  |문자열|+|이항|문자열|두 문자열을 연결|
  |대입|=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=|이항|다양|우변의 값을 좌변의 변수에 대입|
  |증감|++, --|단항|숫자|1만큼 증가/감소|
  |비교|==, !=, >, <, >=, <=, instanceof|이항|boolean|값의 비교|
  |논리|!, &, \|, &&, \|\| |단항, 이항|boolean|논리적 NOT, AND, OR 연산|
  |조건|(조건식)?A:B|삼항|다양|조건식에 따라 A 또는 B 중 하나를 선택|
  |비트|~, &, \|, ^|단항, 이항|숫자, boolean|비트 NOT, AND, OR, XOR 연산|
  |쉬프트|>>, <<, >>>|이항|숫자|비트를 좌측/우측으로 밀어서 이동|
  
  ``` 
  필요한 피연산자의 수에 따 단항, 이항, 삼항 연산자로 구분
  단항 연산자 : ++x;
  이항 연산자 : x + y;
  삼항 연산자 : (sum>90) ? "A" : "B";
  ```
  
  + 연산식은 반드시 하나의 값을 산출, 연산자 수가 아무리 많아도 두 개 이상의 값을 산출하는 연산식은 없음
  + 보통 연산식의 값은 아래와 같이 변수에 저장

  ``` 
  int result = x + y;
  ```
  
  + 연산식은 아래와 같ㅇ 다른 연산식으 피연산 위치에도 올 수 있음

  ``` 
  boolean result = (x+y) < 5;
  // x와 y 변수의 값을 더한 값이 5볻 작은지 확인 후 결과값 true 또는 false를 result에 저장
  ```
  
  
## 연산의 방향과 우선순위
  |연산자|연산 방향|
  |---------|--------|
  |증감(++, --), 부호(+, -), 비트(~), 논리(!)|<--|
  |산술(*, /, %)|-->|
  |산술(+, -)|-->|
  |쉬프트(<<, >>, >>>)|-->|
  |비교(<, >, <=, >=, instanceof)|-->|
  |비교(==, !=)|-->|
  |논리(&)|-->|
  |논리(^)|-->|
  |논리(\|)|-->|
  |논리(&&)|-->|
  |논리(\|\|)|-->|
  |조건(?:)|-->|
  |대입(=, +=, -=, *=, /=, %=, ^=, |=, <<=, >>=, >>>=)|<--|
  + 위에서 아래로 내려올수록 우선순위가 낮아짐
  
  ``` 
  1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.
  2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다.
  3. 단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다. (-->)
  4. 복잡한 연산식에서 괄호()를 사용하여 우선순위를 정해준다.
  ```

## 단항 연산자
### 부호 연산자 (+, -)
  + 양수 및 음수를 표시하는 +, -
  + boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용
  |연산식|설명|
  |-----|-----|
  |+|피연산자의 부호 유지|
  |-|피연산자의 부호 변경|
  ``` 
  int x = -100;
  int result1 = +x; // -100
  int result2 = -x; // 100
  ```
  + 부호 연산자의 산출 타입은 int 타입이라 short 타입 값을 부호 연산하면 int 타입 값으로 변경됨
  ``` 
  short s = 100;
  short result3 = -s; //컴파일 에러
  int result4 = -s;   //
  ```
  
### 증감 연산자 (++, --)
  + 변수의 값을 1 증가(++) 혹은 1 감소(--)
  + boolean 타입을 제외한 모든 기본 타입에 사용
  |연산식|설명|
  |-----|-----|
  |++x|다른 연산을 수행하기 전에 x 값을 1 증가|
  |--x|다른 연산을 수행하기 전에 x 값을 1 감소|
  |x++|다른 연산을 수행한 후에 x 값을 1 증가|
  |x--|다른 연산을 수행한 후에 x 값을 1 감소|
    + ++i, i++ 모두 i = i + 1;로 동일
    + --i, i-- 모두 i = i - 1;로 동일
      + 컴파일 시 ++i랑 i = i + 1은 동일한 바이트 코드가 생성되기 때문에 연산속도는 똑같음
  ``` 
  int x = 1;
  int y = 1;
  int result1 = ++x + 10; //12
  int result1 = y++ + 10; //11
  ```
  
### 논리 부정 연산자 (!)
  + true를 false로 false는 true로 변경하기 때문에 boolean 타입에만 사용

### 비트 반전 연산자 (~)
  + 정수타입(byte, short, int, long)에 사용
  + 피연산자를 2진수로 표현했을 때 비트값인 0을 1으로 1은 0으로 반전 
    + 정수값을 총 32비트의 이진 문자열로 리턴하는 Integer.toBinaryString() 메소드를 사용
  + 부호 비트인 최상위 비트를 포함해 모든 비트가 반전되어 부호가 반대인 새로운 값이 산출
  + 산출 타입은 int 타입
  ``` 
  byte v = 10;
  byte v1 = ~v; //컴파일 에러
  int v1 = ~v;
  ```
  
## 이항 연산자
  + 피연산작 2개인 연산자
  + 산술, 문자열 연결, 대입, 비교, 논리, 비트 논리, 비트 이동 연산자

### 산술 연산자 (+, -, *, /, %)
  + boolean 타입을 제외한 모든 기본 타입에 사용
  ``` 
  a + b : 덧셈 연산
  a - b : 뺄셈 연산
  a * b : 곱셈 연산
  a / b : 좌측 피연산자를 우측 피연산자로 나눗셈 연산
  a % b : 좌측 피연산자를 우측 피연산자로 나눈 나머지를 구하는 연산
  ```
  + 피연산자들이 모두 정수 타입이고 int 타입보다 작은 경우 모두 int 타입으로 변환
  + 피연산자들의 타입이 동일하지 않은 경우 큰 타입의 피연산자 타입으로 피연산자들의 타입을 일치시킨 후 연산
  + 피연산자 중 하나랃 실수 타입이며 실수 타입으로 산출
    + 예1) byte + int -> int + int = int
    + 예2) int + long -> long + long = long 
    + 예3) int + double -> double + double = double
  + char 타입도 정수 타입이므로 산술 연산 시 int 타입으로 산출
  ``` 
  char c = 'A';
  char c1 = c + 1; //컴파일 에러
  char c1 = (char) (c + 1);
  ```

### 문자열 연결 연산자 (+)
  + 문자열을 서로 결합하는 연산자
  ``` 
  String str1 = "JDK" + 6.0; //JDK6.0
  String str2 = str1 + " 특징"; //JDK6.0 특징
  ``` 
  
### 비교 연산자 (<, <=, >, >=, ==, !=)
  + boolean 타입인 true/false를 산출
  + 대소 연산자(<, <=, >, >=)는 boolaen 타입을 제외한 기본 타입에 사용 가능
  + 동등 연산자(==, !=)는 모든 타입에 사용 가능
  + 비교 연산자는 흐름 제어문인 조건문(if), 반복문(for, while)에서 주로 사용

### 논리 연산자 (&&, ||, &, |, ^, !)
  + 논리곱 AND &&, &
 
  |피연산자|연산자|피연산자|결과|
  |----|----|----|----|
  |true|&& / &|true|true|
  |true|&& / &|false|false|
  |false|&& / &|true|false|
  |false|&& / &|false|false|
  
  --> 피연산자 모두가 true일 경우 true
  + 논리합 OR ||, |
 
  |피연산자|연산자|피연산자|결과|
  |----|----|----|----|
  |true|\|\| / \||true|true|
  |true|\|\| / \||false|true|
  |false|\|\| / \||true|true|
  |false|\|\| / \||false|false|
  
  --> 피연산자 하나만 true여도 true
  + 배타적논리합 XOR ^
 
  |피연산자|연산자|피연산자|결과|
  |----|----|----|----|
  |true|^|true|false|
  |true|^|false|true|
  |false|^|true|true|
  |false|^|false|false|
  
  --> 피연산자 하나는 true이고 다른 하나가 false인 경우 true

  + 논리부정 NOT !
 
  |연산자|피연산자|결과|
  |----|----|----|
  |!|true|false|
  |!|false|true|
  
  --> 피연산자의 논리값을 바꿈
  
### 비트 연산자 (&, |, ^, ~, <<, >>, >>>)
  + 논리곱 &
 
  |피연산자|연산자|피연산자|결과|
  |----|----|----|----|
  |1|&|1|1|
  |1|&|0|0|
  |0|&|1|0|
  |0|&|0|0|
  
  --> 두 비트가 모두 1일 경우에만 연산 결과가 1
  
  + 논리합 |
 
  |피연산자|연산자|피연산자|결과|
  |----|----|----|----|
  |1|\||1|1|
  |1|\||0|1|
  |0|\||1|1|
  |0|\||0|0|
  
  --> 둘 중 하나만 1이면 1
  
  + 배타적 논리합 ^
 
  |피연산자|연산자|피연산자|결과|
  |----|----|----|----|
  |1|^|1|0|
  |1|^|0|1|
  |0|^|1|1|
  |0|^|0|0|
  
  --> 하나는1이고 다른 하나가 0이면 1
  
  + 논리부정 NOT ~
 
  |연산자|피연산자|결과|
  |----|----|----|
  |~|1|0|
  |~|0|1|
  
  --> 보수
  
  + 비트 이동 연산자
  
  |피연산자|연산자|피연산자|설명|
  |----|----|----|----|
  |a|<<|b|정수 a의 각 비트를 b만큼 왼쪽으로 이동 (빈자리는 0으로 채움)|
  |a|>>|b|정수 a의 각 비트를 b만큼 오른쪽으로 이동 (빈자리는 정수 a의 최상위 부호 비트와 같은 값으로 채워짐)|
  |a|>>>|b|정수 a의 각 비트를 b만큼 오른쪽으로 이동 (빈자리는 0으로 채움)|
  
### 대입 연산자
  |연산식|설명|
  |----|----|
  |x = y|y 값을 x에 저장|
  |x += y|x와 y를 더한 값을 x에 저장 (x = x + y)|
  |x -= y|x와 y를 뺀 값을 x에 저장 (x = x - y)|
  |x *= y|x와 y를 곱한 값을 x에 저장 (x = x * y)|
  |x /= y|x와 y를 나눈 값을 x에 저장 (x = x / y)|
  |x %= y|x와 y를 나눈 후 나머지 값을 x에 저장 (x = x % y)|
  |x &= y|x와 y를 & 연산 후 x에 저장 (x = x & y)|
  |x \|= y|x와 y를 \| 연산 후 x에 저장 (x = x \| y)|
  |x ^= y|x와 y를 ^ 연산 후 x에 저장 (x = x ^ y)|
  |x <<= y|x와 y를 << 연산 후 x에 저장 (x = x << y)|
  |x >>= y|x와 y를 >> 연산 후 x에 저장 (x = x >> y)|
  |x >>>= y|x와 y를 >>> 연산 후 x에 저장 (x = x >>> y)|
  
  
## 삼항 연산자
  + 세 개의 피연산자를 필요로 하는 연산자
  + ? 앞에 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다해서 조건 연산식이라고도 부름
  ``` 
  조건식      ?    값 또는 연산식   :  값 또는 연산식
  피연산자1        피연산자2(true)    피연산자3(false)
  ```
